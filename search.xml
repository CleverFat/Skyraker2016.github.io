<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python作业02-列表]]></title>
    <url>%2F2018%2F03%2F13%2FPython%E4%BD%9C%E4%B8%9A02-%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[DescriptionSelect from exercise 3-1 to 4-15 Code3-1 &amp; 3-212345678# 3-1 姓名: 将一些朋友的姓名存储在一个列表中，并将其命名为names。# 依次访问该列表中的每个元素，从而将每个朋友的姓名都打印出来。# 3-2 问候语：继续使用练习3-1中的列表，但不打印每个朋友的姓名，# 而为每人打印一条消息。每条消息都包含相同的问候语，但抬头为相应朋友的姓名。names = ["tony", "marry","tom","ma"]for name in names: print(name.title()+": ") print("Hello, "+name+" .") result: 12345678910Tony: Hello, tony .Marry: Hello, marry .Tom: Hello, tom .Ma: Hello, ma .Process finished with exit code 0 3-4 ~ 3-73-4123456# 3-4 嘉宾名单 ：如果你可以邀请任何人一起共进晚餐（无论是在世的还是故去的），# 你会邀请哪些人？请创建一个列表，其中包含至少3个你想邀请的人；# 然后，使用这个列表打印消息，邀请这些人来与你共进晚餐。names = ["Tom","Raker", "Gakki"]for name in names: print("Hi, "+name+" .Would you like to have dinner with me?") result: 123Hi, Tom .Would you like to have dinner with me?Hi, Raker .Would you like to have dinner with me?Hi, Gakki .Would you like to have dinner with me? 3-512345678# 3-5 以完成练习3-4时编写的程序为基础，在程序末尾添加一条print 语句，指出哪位嘉宾无法赴约。# 修改嘉宾名单，将无法赴约的嘉宾的姓名替换为新邀请的嘉宾的姓名。# 再次打印一系列消息，向名单中的每位嘉宾发出邀请。new_name = "Tony"print(names[1]+" cannot come, "+new_name+" will instead.")names[1] = new_namefor name in names: print("Hi, " + name + " .Would you like to have dinner with me?") result: 1234Raker cannot come, Tony will instead.Hi, Tom .Would you like to have dinner with me?Hi, Tony .Would you like to have dinner with me?Hi, Gakki .Would you like to have dinner with me? 3-6123456789101112# 3-6 添加嘉宾 ：你刚找到了一个更大的餐桌，可容纳更多的嘉宾。请想想你还想邀请哪三位嘉宾。# 以完成练习3-4或练习3-5时编写的程序为基础，在程序末尾添加一条print 语句，指出你找到了一个更大的餐桌。# 使用insert() 将一位新嘉宾添加到名单开头。# 使用insert() 将另一位新嘉宾添加到名单中间。# 使用append() 将最后一位新嘉宾添加到名单末尾。# 打印一系列消息，向名单中的每位嘉宾发出邀请。print("Good news! I find a larger table!")names.insert(0,"Dollus")names.insert(2,"Sam")names.append("Lilith")for name in names: print("Hi, " + name + " .Would you like to have dinner with me?") result: 1234567Good news! I find a larger table!Hi, Dollus .Would you like to have dinner with me?Hi, Tom .Would you like to have dinner with me?Hi, Sam .Would you like to have dinner with me?Hi, Tony .Would you like to have dinner with me?Hi, Gakki .Would you like to have dinner with me?Hi, Lilith .Would you like to have dinner with me? 3-71234567891011121314# 3-7 缩减名单 ：你刚得知新购买的餐桌无法及时送达，因此只能邀请两位嘉宾。# 以完成练习3-6时编写的程序为基础，在程序末尾添加一行代码，打印一条你只能邀请两位嘉宾共进晚餐的消息。# 使用pop() 不断地删除名单中的嘉宾，直到只有两位嘉宾为止。每次从名单中弹出一位嘉宾时，都打印一条消息，让该嘉宾知悉你很抱歉，无法邀请他来共进晚餐。# 对于余下的两位嘉宾中的每一位，都打印一条消息，指出他依然在受邀人之列。# 使用del 将最后两位嘉宾从名单中删除，让名单变成空的。打印该名单，核实程序结束时名单确实是空的。print("I'm sorry to tell you that, my new table cannot arrive in time, so I can only invite 2.")while len(names)&gt;2: sorry_name = names.pop() print("Hi "+sorry_name+", I'm sorry to tell you that I cannot have dinner with you.")for name in names: print("Hey "+name+", you are still in my invite list!")del names[0]del names[0]print(names) result: 12345678I'm sorry to tell you that, my new table cannot arrive in time, so I can only invite 2.Hi Lilith, I'm sorry to tell you that I cannot have dinner with you.Hi Gakki, I'm sorry to tell you that I cannot have dinner with you.Hi Tony, I'm sorry to tell you that I cannot have dinner with you.Hi Sam, I'm sorry to tell you that I cannot have dinner with you.Hey Dollus, you are still in my invite list!Hey Tom, you are still in my invite list![] 3-8 ~ 3-113-81234567891011121314151617181920212223242526272829303132333435# 3-8 放眼世界 ：想出至少5个你渴望去旅游的地方。places = ["Egypt", "Tibet", "France", "Russia", "Australia"]# 将这些地方存储在一个列表中，并确保其中的元素不是按字母顺序排列的。print("按原始排列顺序打印该列表。不要考虑输出是否整洁的问题，只管打印原始Python列表:")print(places)print("使用sorted() 按字母顺序打印这个列表，同时不要修改它:")print(sorted(places))print("再次打印该列表，核实排列顺序未变:")print(places)print("使用sorted() 按与字母顺序相反的顺序打印这个列表，同时不要修改它:")print(sorted(places, reverse=True))print("再次打印该列表，核实排列顺序未变:")print(places)print("使用reverse() 修改列表元素的排列顺序。打印该列表，核实排列顺序确实变了:")places.reverse()print(places)print("使用reverse() 再次修改列表元素的排列顺序。打印该列表，核实已恢复到原来的排列顺序:")places.reverse()print(places)print("使用sort() 修改该列表，使其元素按字母顺序排列。打印该列表，核实排列顺序确实变了:")places.sort()print(places)print("使用sort() 修改该列表，使其元素按与字母顺序相反的顺序排列。打印该列表，核实排列顺序确实变了:")places.sort(reverse=True)print(places) result: 1234567891011121314151617181920按原始排列顺序打印该列表。不要考虑输出是否整洁的问题，只管打印原始Python列表:['Egypt', 'Tibet', 'France', 'Russia', 'Australia']使用sorted() 按字母顺序打印这个列表，同时不要修改它:['Australia', 'Egypt', 'France', 'Russia', 'Tibet']再次打印该列表，核实排列顺序未变:['Egypt', 'Tibet', 'France', 'Russia', 'Australia']使用sorted() 按与字母顺序相反的顺序打印这个列表，同时不要修改它:['Tibet', 'Russia', 'France', 'Egypt', 'Australia']再次打印该列表，核实排列顺序未变:['Egypt', 'Tibet', 'France', 'Russia', 'Australia']使用reverse() 修改列表元素的排列顺序。打印该列表，核实排列顺序确实变了:['Australia', 'Russia', 'France', 'Tibet', 'Egypt']使用reverse() 再次修改列表元素的排列顺序。打印该列表，核实已恢复到原来的排列顺序:['Egypt', 'Tibet', 'France', 'Russia', 'Australia']使用sort() 修改该列表，使其元素按字母顺序排列。打印该列表，核实排列顺序确实变了:['Australia', 'Egypt', 'France', 'Russia', 'Tibet']使用sort() 修改该列表，使其元素按与字母顺序相反的顺序排列。打印该列表，核实排列顺序确实变了:['Tibet', 'Russia', 'France', 'Egypt', 'Australia']Process finished with exit code 0 3-912# 使用len()打印一条消息，指出想要游玩多少个国家。print("I want to go "+str(len(places))+" places.") result: 1I want to go 5 places. 3-111234# 3-11 有意引发错误 ：如果你还没有在程序中遇到过索引错误，就尝试引发一个这种错误。# 在你的一个程序中，修改其中的索引，以引发索引错误。关闭程序前，# 务必消除这个错误。print(places[7]) result: 123File "D:/pyproject/homework1/3-8.py", line 43, in &lt;module&gt; print(places[7])IndexError: list index out of range 4-212345678910# 4-2 动物 ：想出至少三种有共同特征的动物，将这些动物的名称存储在一个列表中，再使用for 循环将每种动物的名称都打印出来。animals = ["dog", "cat", "hamster"]for animal in animals: print(animal)# 修改这个程序，使其针对每种动物都打印一个句子，如“A dog would make a great pet”。for animal in animals: print("A "+animal+" would make a good pet.")# 在程序末尾添加一行代码，指出这些动物的共同之处，如打印诸如“Any of these animals would make a great pet!”这样的句子。print("Any of these animals would make a greate pet!") result:123456789dogcathamsterA dog would make a good pet.A cat would make a good pet.A hamster would make a good pet.Any of these animals would make a greate pet!Process finished with exit code 0 4-3 ~ 4-94-3123# 4-3 数到20 ：使用一个for 循环打印数字1~20（含）。for number in range(1, 21): print(number) result:12345678910111213141516171819201234567891011121314151617181920 4-5123456# 4-5 计算1~1 000 000的总和 ：创建一个列表，其中包含数字1~1 000 000，再使用min() 和max() 核实该列表确实是从1开始，# 到1 000 000结束的。另外，对这个列表调用函数sum() ，看看Python将一百万个数字相加需要多长时间。numbers = range(1, 1000001)print(min(numbers))print(max(numbers))print(sum(numbers)) result:12311000000500000500000 4-61234# 4-6 奇数 ：通过给函数range() 指定第三个参数来创建一个列表，其中包含1~20的奇数；再使用一个for 循环将这些数字都打印出来。odd_numbers = range(1,20,2)for odd_number in odd_numbers: print(odd_number) result:12345678910135791113151719 4-9123# 4-9 立方解析 ：使用列表解析生成一个列表，其中包含前10个整数的立方。cube_numbers = [ number**3 for number in range(1,11)]print(cube_numbers) result:1[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000] 4-10 &amp; 4-114-1012345678910# 4-10 切片 ：选择你在本章编写的一个程序，在末尾添加几行代码，以完成如下任务。# 打印消息“The first three items in the list are:”，再使用切片来打印列表的前三个元素。# 打印消息“Three items from the middle of the list are:”，再使用切片来打印列表中间的三个元素。# 打印消息“The last three items in the list are:”，再使用切片来打印列表末尾的三个元素。print("The first three items in the list are:")print(cube_numbers[:3])print("Three items from the middle of the list are:")print(cube_numbers[3:6])print("The last three items in the list are:")print(cube_numbers[6:]) result:123456The first three items in the list are:[1, 8, 27]Three items from the middle of the list are:[64, 125, 216]The last three items in the list are:[343, 512, 729, 1000] 4-11copy a list123456789101112131415161718print("list A:")A = ["A", "E", "I", "O"]print(A)print("list B copy from A:")B = A[:]print(B)print("Change B and A didn't change:")B.append("U")print(A)print(B)print("C equal to A directly:")C = Aprint(A)print(C)print("C change and make A change:")C.pop()print(A)print(C) result:12345678910111213list A:['A', 'E', 'I', 'O']list B copy from A:['A', 'E', 'I', 'O']Change B and A didn't change:['A', 'E', 'I', 'O']['A', 'E', 'I', 'O', 'U']C equal to A directly:['A', 'E', 'I', 'O']['A', 'E', 'I', 'O']C change and make A change:['A', 'E', 'I']['A', 'E', 'I'] 4-1312345# 4-13 自助餐 ：有一家自助式餐馆，只提供五种简单的食品。请想出五种简单的食品，并将其存储在一个元组中。# 使用一个for 循环将该餐馆提供的五种食品都打印出来。foods = ("apple", "juice", "pizza", "noodles", "egg")for food in foods: print(food) result:12345applejuicepizzanoodlesegg 12# 尝试修改其中的一个元素，核实Python确实会拒绝你这样做。foods[3] = "chicken" result:123456Traceback (most recent call last): File "D:/pyproject/homework1/4-2.py", line 18, in &lt;module&gt; foods[3] = "chicken"TypeError: 'tuple' object does not support item assignmentProcess finished with exit code 1 12345# 餐馆调整了菜单，替换了它提供的其中两种食品。请编写一个这样的代码块：# 给元组变量赋值，并使用一个for 循环将新元组的每个元素都打印出来。foods = ("apple", "cola", "cabbage", "noodles", "egg")for food in foods: print(food) result:12345applecolacabbagenoodlesegg PEP格式指南 四空格缩进 行最长不超过80字符 不要在程序中过多地使用空行 适当的注释 …]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello blog again]]></title>
    <url>%2F2018%2F03%2F11%2Fhello-blog-again%2F</url>
    <content type="text"><![CDATA[之前的博客是直接克隆自他人的博客代码再进行修改，不太好意思。而且不自己从开始建的话，很多配置用不了、不知道如何更改，因此趁周末闲暇从新用hexo建站并上传至GitHub Pages，并配置好了主题等，特地记录一下踩过的、好的文章和添加的功能。 搭建过程及相关教程下载hexo在桌面右键选择Git Bash here，并输入 npm install -g hexo-cli 等待安装，找个网络比较好的地方等吧…… 接下来具体的部署内容详见这个教程，算是见得比较全的一篇教程了。 添加主题NexT将主题下载然后放进/theme，我这里用的是NexT主题。具体参见NexT项目，以及使用文档 添加的功能 RSS订阅 添加分类页 背景动画 站内搜索 访问量统计 使用Gitment添加评论 支持markdown代码高亮 踩过的坑markdown编辑器的选择一开始用的NotePad++，首先是不支持预览，其次是它的front-matter添加后会被当成普通的markdown语法。因此现在改用vscode进行markdown的编辑器。 具体的使用方法：打开.md文件进行编辑，按Ctrl+k再按v即可打开预览窗口，效果如下： 使用Gitment添加评论 NexT预置Gitment： 一开始使用Gitment添加时找到的是过去版本的教程，需要修改代码，但是在修改的过程中突然发现原本的文件已经包含了Gitment模块，这才知道NexT的新版本已经预置了Gitment，配置方法参考自这里。 关于Error: Not Found: 配置时要注意仓库名称要是该仓库本名，而非SSH或HTTPS，例如我的就是Skyraker.github.io。 关于Error：validation failed: Gitment的原理就是在关联你的项目，每一个页面下的评论对应一个issue，并给那个issue建立标签gitment和id，其中id是Gitment唯一确定评论显示于哪个位置的特征。而出现Error：validation failed是因为id超出了issue的50个字符的限制。这个id是怎么来的呢？ 在相应的主题中搜索Gitment即可定位至gitment.swig，打开找到id可以看到： id: window.location.pathname, 即当前id为这个页面在本站中的路径。当文章title为中文时，转码会导致id过长。我们可以改路径名（即permlink）,具体详见这里，或者改id为 id: &apos;{{ page.date }}&apos; 或 id: &apos;{{ page.title }}&apos; 以缩短id，但注意这两个数据必须是唯一的，不能重复，否则评论会在多个页面共享。参考并修改自这里 初始化本页页面后，可能没那么快加载出来，不要重复初始化，否则会出现两个相同的issue 代码高亮在站点配置文件中，修改配置： highlight: enable: true auto_detect: true line_number: true tab_replace: 即可打开代码高亮的自动探测、行号显示。 在主题配置文件中，修改配置选择高亮风格： 12345# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night 最后在编辑markdown时，引用代码，可以得到如下效果：123456#include &lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;"Hello world!"&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>others</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OS学习笔记01-接管裸机控制权]]></title>
    <url>%2F2018%2F03%2F10%2FOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(01)%E6%8E%A5%E7%AE%A1%E8%A3%B8%E6%9C%BA%E6%8E%A7%E5%88%B6%E6%9D%83%2F</url>
    <content type="text"><![CDATA[实验任务设计一个引导扇区程序，程序功能是：在屏幕上显示运动内容，并在触碰到边框时反弹，可以加入变色等其它功能。将这个程序的机器码放进放进虚拟软盘的首扇区，并用此软盘引导无操作系统的虚拟机，直到成功。 基础原理主引导记录（MBR）工作原理：计算机启动后，由BIOS检查硬件并根据指定的顺序，检查引导设备（本次实验中的虚拟软盘）的第一扇区（即前512B且以0x55AA结尾的内容，也就是我们的主引导记录），加载至内存地址0x7C00，并开始运行；其它内存地址如下所示： 显示原理：显存首地址为0xB800，以两个字节来控制相应屏幕位置的显示内容。其中低字节为显示字符的ascii码，高字节为显示颜色，显示颜色如下表： 其中，颜色默认为0x07，即黑底白字； 实验工具和环境说明 编辑器：Notepad++，支持语法高亮； 汇编器：NASM，与MASM有部分区别，后文详述； 机器码编辑器：WinHex，用于对COM进行修改使其符合MBR的格式 虚拟机：VMware，用于生成裸机 程序流程及源码显示个人信息跳动规迹，并变色； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222;显示学号姓名缩写 DRt equ 1 ;D-Down,U-Up,R-right,L-Left URt equ 2 ; ULt equ 3 ; DLt equ 4 ; delay equ 50000 ;计时器延迟计数,用于控制画框的速度 ddelay equ 580 ;延迟580*50000次 Hm equ 25 ;最大高度 Lm equ 80 ;最大宽度 len equ 14 ;字符串长度 BOOTSEG equ 0x7c00 ;段基址0x7c00 DISPLAYSEG equ 0xb800 ;显存及地址0xb800 org BOOTSEG ;告诉汇编器要在0x7c00执行 section .text_start: ;初始化数据段，使其指向0X7C00处，即Boot代码被加载的地方 mov ax, cs mov ds, ax ;将文本显示内存段基址 放在ES中，供后面显示字符使用 mov ax, DISPLAYSEG mov es, ax loop1: dec word[count] ; 递减计数变量 jnz loop1 ; &gt;0：跳转; mov word[count],delay dec word[dcount] ; 递减计数变量 jnz loop1 mov word[count],delay mov word[dcount],ddelay ;mov al, 20H ;空格覆盖 ;mov ah, 0FH ;mov [es:bx], ax dec byte[color] cmp byte[color], 01H jz resetback: mov al, DRt ;↘ cmp al, byte[dir] jz DRF mov al, DLt ;↙ cmp al, byte[dir] jz DLF mov al, URt ;↗ cmp al, byte[dir] jz URF mov al, ULt ;↖ cmp al, byte[dir] jz ULF jmp $DRF: inc word[x] inc word[y] ;向右下前进一格 mov ax, Hm mov bx, word[x] ;判断x是否越界 cmp ax, bx jz dr2ur mov ax, Lm-len mov bx, word[y] ;判断y是否越界 cmp ax, bx jz dr2dl jmp displaydr2ur: ;回弹——从右下改为右上 mov word[x], Hm-2 mov ax, Lm-len ;判断是否为角落 mov bx, word[y] cmp ax, bx jz drA mov byte[dir], URt jmp displaydr2dl: mov word[y], Lm-len-2 mov byte[dir], DLt jmp displaydrA: ;角落时原路返回 mov word[y],Lm-len-2 mov byte[dir], ULt jmp display DLF: inc word[x] dec word[y] mov ax, Hm mov bx, word[x] cmp ax, bx jz dl2ul mov ax, -1 mov bx, word[y] cmp ax, bx jz dl2dr jmp displaydl2ul: mov word[x], Hm-2 mov ax, -1 mov bx, word[y] cmp ax, bx jz dlA mov byte[dir], ULt jmp displaydl2dr: mov word[y], 1 mov byte[dir], DRt jmp displaydlA: mov word[y], 1 mov byte[dir], URt jmp display URF: dec word[x] inc word[y] mov ax, -1 mov bx, word[x] cmp ax, bx jz ur2dr mov ax, Lm-len mov bx, word[y] cmp ax, bx jz ur2ul jmp displayur2dr: mov word[x], 1 mov ax, Lm-len mov bx, word[y] cmp ax, bx jz urA mov byte[dir], DRt jmp displayur2ul: mov word[y], Lm-len-2 mov byte[dir], ULt jmp displayurA: mov word[y], Lm-len-2 mov byte[dir], DLt jmp display ULF: dec word[x] dec word[y] mov ax, -1 mov bx, word[x] cmp ax, bx jz ul2dl mov ax, -1 mov bx, word[y] cmp ax, bx jz ul2ur jmp displayul2dl: mov word[x], 1 mov ax, -1 mov bx, word[y] cmp ax, bx jz ulA mov byte[dir], DLt jmp displayul2ur: mov word[y], 1 mov byte[dir], URt jmp displayulA: mov word[y], 1 mov byte[dir], DRt jmp display display: ;显示模块 mov ax, word[x] mov bx, Lm mul bx add ax, word[y] mov bx, 2 mul bx mov bx, ax ;bx = ax = (x*80+y) * 2 mov cx, len mov si, info mov ah, [color]loop_str: ;字符串显示模块 mov al, [si] mov [es:bx], ax inc si inc bx inc bx loop loop_str jmp loop1reset: mov byte[color], 0FH jmp backend: jmp $;section .data info db " ygz 16337287 ",0 count dw delay dcount dw ddelay dir db DRt ; 向右下运动 x dw 2 y dw 0 color db 0FH times 510-($-$$) db 0 ;填充空格 dw 0xaa55 实验步骤 在NotePad++中进行编辑程序; 在生成软盘文件： 打开CMD终端窗口至asm文件所在的文件夹，输入nasm -f bin %name%.asm -o %name%.com &gt; amsg.txt（%name%为文件名）； 或直接输入na %name%.asm快速生成com文件，na.bat内容如下：@echo offset name=%~n1nasm -f bin %name%.asm -o %name%.COM &gt; amsg.txttype amsg.txt |find “Error”type amsg.txt |find “Warn” 生成com文件，打开com文件将0x1FE和0x1FF改为0x55和0xAA，保存为flp软盘格式: 另：若代码末尾已经加上了times 510-($-$$) db 0 ;填充空格dw 0xaa55 ;加上55AA，符合MBR特征则不必再修改com文件，直接生成为flp文件即可 创建无操作系统的裸机： 将flp文件装载进虚拟机作为MBR引导启动： 结果截图 显示有规迹的‘A’： 显示动态无规迹的‘A’+固定的个人信息‘ ygz 16337287 ’： 逐字显示动态变色个人信息，并保留痕迹： 整行显示动态变色个人信息： 接下来就是各种踩坑和填坑的经历了 关于NASM： NASM的标识符区分大小写； NASM中，memory操作数直接是内容地址，并且不保存数据类型，导致以下两个区别： 在读取数据内容时，要加方括号[ ] 指明是地址的内容，若没有方括号则是首地址的值； 在操作数据内容时且另一个操作数是常数（非ax、ah这种能够知道数据大小的寄存器），要加上数据类型如byte、word等； 不需要ptr指示字； 提供segment时，NASM要在方括号内提供segment，如：MOV [es:bx], ax 段定义方式，NASM定义数据段section .data，定义代码段section .text equ类似C语言中的define，用于定义整数常量；（注意，不能定义浮点数，且最长为8bytes） 用times来重复定义数据或指令 $为当前nasm编译后当前指令位置，$$为该段的初始位置。一开始在没弄懂$$的情况下照猫画虎胡乱使用，导致生成的文件大于512B且0x55AA位置错误（虽然没有影响），后来去掉了section .data后即可（即让后面的数据处于与代码的同一段，以便于计算总体机器码的大小）。 其它的NASM需要注意的语法待后面的实验探索。关于加载至0x7c00：BIOS检查了引导设备的第一个扇区（以0x55AA结尾的512B）即主引导记录（MBR），加载至0x7c00，因此默认偏移为0x7c00。至于为什么时0x7c00，是由于一开始的8088CPU内存为32KB，即0~0x7FFF，保留512B给MBR，512B保留给MBR产生的数据，为了让出足够的空间给操作系统，因此从后开始算，0x7FFF-1024 = 0x7c00;关于org的作用及思考：根据上一条，我们的代码将会被强制加载到0x7c00，因此若没有org，后面的memory操作数会默认从0开始算。 例如在相对位置3做了如下定义： msg db ‘@’ 在没有org的情况下，[msg]会在0x03读取一位，而真正的数据‘@’被加载到了0x7c03，在读取[msg]的时候就会读到乱码。 在有org 0x7c00的情况下，[msg]会直接去0x7c03读取’@’。 以上可以在生成机器码后，通过反汇编看出。总的来说，org就是告诉汇编器，该代码必然会被加载到某一偏移值上，因此要告诉汇编器后面的相对地址要加上偏移值。 这也就能够解释一个现象：明明在数据段中初始化了数据，却无法读取，只能在代码开头重新mov一遍才能正常输出，但是重复mov时的目的地址为0x7c00前面的某个位置，造成别的内存的篡改，产生不可预计的后果。 关于算法的错误： 角落判断：在一开始的设计中，仅分别判断了x和y的位置，若字符运行至角落，仅仅将x反弹，而y会继续运动，而且运动方向也会错误，导致一次显示错误的同时也造成了y的越界，且会越跑越远，最终让字符完全移出屏幕，如下图可见在后期字符的反弹条件已经错误了 修改方法：在判断x越界后的反弹程序中，判断y是否同时越界，若是，则将路径原路返回 在部分不需要写回的相等判断中，用了sub，其实用cmp即可； 不足及优化设想：在整体信息输出弹跳时，本想着每次弹跳后才变色的，视觉效果会好很多，但是在弹跳时加了判断后（即十二种弹跳），会超出512B限制,导致部分指令无法装载。有两种优化设想： 将DRt等数据不局限于一个特征数，而是按规律如上下分别为1、0来进行编写，在弹跳时通过运算来更改路径，合并重复逻辑； 在MBR中进行引导而非操作，真正的操作放在操作系统的位置执行。 这两种方法都有待进一步的实践。 入门摸索，难免有纰漏，欢迎各位大佬批评指正 参考资料 “Hello world” 引导程序 NASM与MASM语法区别 主引导记录内存地址是0x7c00 关于org 0x7c00的原因]]></content>
      <categories>
        <category>OS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python作业01-变量和简单数据类型]]></title>
    <url>%2F2018%2F03%2F08%2F2018-03-08-Python%E4%BD%9C%E4%B8%9A01-%E5%8F%98%E9%87%8F%E5%92%8C%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[DescriptionSelect from exercise 2-1 to 2-11. I will finish the code with comment about the requirement. Code2-3123456# 2-3 个性化消息： 将用户的姓名存到一个变量中，# 并向该用户显示一条消息。显示的消息应非常简单，# 如“Hello Eric, would you like to learn some Python today?”。name = input()print("Hello " + name + ", would you like to learn some Python today?") result: D:\pyproject\homework1\venv\Scripts\python.exe D:/pyproject/homework1/2_3.py Jobs Hello Jobs, would you like to learn some Python today? Process finished with exit code 0 2-41234567# 2-4 调整名字的大小写： 将一个人名存储到一个变量中，# 再以小写、大写和首字母大写的方式显示这个人名。name = input()print(name.upper())print(name.lower())print(name.title()) result: D:\pyproject\homework1\venv\Scripts\python.exe D:/pyproject/homework1/2_4.py sKy raKeR SKY RAKER sky raker Sky Raker Process finished with exit code 0 2-71234567891011121314151617# 2-7 剔除人名中的空白： 存储一个人名，# 并在其开头和末尾都包含一些空白字符。# 务必至少使用字符组合"\t" 和"\n" 各一次。# 打印这个人名，以显示其开头和末尾的空白。# 然后，分别使用剔除函数lstrip() 、rstrip()# 和strip() 对人名进行处理，并将结果打印出来。name = "\n\tSky Raker\t\n\t"print("-------------")print(name)print("-------------")print(name.lstrip())print("-------------")print(name.rstrip())print("-------------")print(name.strip())print("-------------") result: D:\pyproject\homework1\venv\Scripts\python.exe D:/pyproject/homework1/2_7.py ------------- Sky Raker ------------- Sky Raker ------------- Sky Raker ------------- Sky Raker ------------- Process finished with exit code 0 2-812345678# 2-8 数字8： 编写4个表达式，它们分别使用# 加法、减法、乘法和除法运算，但结果都是数字8。# 为使用print 语句来显示结果，务必将这些表达式用括号括起来，print(3+5)print(10-2)print(2*4)print(1000/125) result: D:\pyproject\homework1\venv\Scripts\python.exe D:/pyproject/homework1/2_8.py 8 8 8 8.0 Process finished with exit code 0 2-111234# 2-11 Python之禅： 在Python终端会话中执行命令import this ，# 并粗略地浏览一下其他的指导原则。import this result: D:\pyproject\homework1\venv\Scripts\python.exe D:/pyproject/homework1/2_11.py The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren&apos;t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you&apos;re Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it&apos;s a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let&apos;s do more of those! Process finished with exit code 0]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello Python]]></title>
    <url>%2F2018%2F03%2F06%2F2018-03-06-Hello-Python%2F</url>
    <content type="text"><![CDATA[Python 的优点作为一个流行的解释型语言，python具有以下优点： 拥有许多强大的库，以支持python在各个领域的使用，也是许多人开始学习python的原因,例如： Web框架方面的Django等 科学计算方面的NumPy和SciPy等 用于解析HTML等的BeautifulSoup 用于图像处理的PIL以及支持python3的Pillow 用于多媒体、游戏开发的PyGame 机器学习的scikit-learn … 对初学者友好的学习曲线 … Python 的使用若仅仅进行少量的代码编写，可以使用文本编辑器写python代码再放到解释器下运行。若要进行更多的开发，可以用IDE，例如PyCharm、Eclipse&#39;s PyDev或轻量级的Geany。我目前使用的是PyCharm。 Python 官网探索在学习python之初，我们来看一下它官网的内容：Python 1. 社区：可以进行讨论交流、参与会议、参与活动等等； 2. 初学引导：初学者入门的手册、指南、帮助等； 3. 下载：python的相关下载、环境配置； 4. 帮助文档：在学习时要多参考帮助文档，里面有针对初学、进阶等各个阶段的帮助； 5. 最新关于python的新闻； 6. 即将到来的活动； 7. python的应用领域以及相关库； 网页上还有其它的类似成功故事、新闻、加入团队等链接就不一一赘述了。 目标 掌握python编程思想和基本语法，对常用库有一定的了解； 能够在日常生活中应用python脚本解决一些重复性的、机械的问题； 用python写爬虫，并学会用python进行数据处理； 希望能够利用python去学习一些机器学习的内容。 在python中输入import this，会出现一首诗Zen of Python: The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren&apos;t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you&apos;re Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it&apos;s a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let&apos;s do more of those! 与各位共勉！]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello Blog]]></title>
    <url>%2F2018%2F03%2F06%2F2018-03-06-Hello-Blog%2F</url>
    <content type="text"><![CDATA[Hello Blog在很久之前就有搭一个自己的博客的想法，但是一直缺乏行动，同样的，一直想开始使用GitHub也没有静下心来研究一下。正巧《高级编程技术》的老师要求把作业项目提交到博客上，借着这次机会尝试使用GitHub Pages进行个人博客的搭建，尝试过hexo和jekyll都没有成功，只能cloneYanB大佬的博客，再参照所使用的NexT模板进行修改。另外，大佬还推荐了一个在线编辑GitHub Pages上博客的在线编辑平台prose，可以在线修改编辑博客并上传。很感谢大佬的教学！ 博客内容这个博客将会分享一些在学习过程中的心得、参与的项目以及其它的一些想分享的东西。未来或许会尝试用英文写作。希望能养成写博客的习惯，及时总结。 需要改进的地方 markdown的代码高亮配置。 虽然借助别人已经生成的模板也搭建出来了现在的这个博客，但依旧希望能够学会用jekyll并用来进行进一步的个性化调整。 挖掘博客的一些有趣的应用。]]></content>
      <categories>
        <category>others</category>
      </categories>
  </entry>
</search>
